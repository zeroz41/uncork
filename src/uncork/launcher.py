"""
Launcher script and desktop file generation.

Generates the shell scripts that handle first-run initialization
and Wine execution, plus .desktop files for menu integration.
"""

from __future__ import annotations

from pathlib import Path
from textwrap import dedent

from uncork.spec import PackageSpec, Executable, WineMode


def generate_launcher_script(spec: PackageSpec, exe: Executable) -> str:
    """
    Generate launcher shell script for an executable.
    
    The script handles:
    - First-run prefix initialization (copy or overlay)
    - Path token replacement
    - Wine binary selection (system vs bundled)
    - Environment setup
    """
    
    system_path = spec.get_system_path()
    user_data_path = spec.get_user_data_path()
    
    if spec.install.use_overlay:
        init_block = _generate_overlay_init(system_path, user_data_path)
    else:
        init_block = _generate_copy_init(system_path, user_data_path)
    
    if spec.wine.mode == WineMode.BUNDLED:
        wine_block = _generate_bundled_wine_block(system_path, spec.wine.bundled_path or "")
    else:
        wine_block = _generate_system_wine_block()
    
    # Working directory - resolve relative to prefix
    work_dir = exe.working_dir or str(Path(exe.path).parent)
    
    script = dedent(f'''\
        #!/bin/bash
        # Generated by uncork
        # Launcher for {exe.name}
        
        set -e
        
        APP_NAME="{spec.app.name}"
        SYSTEM_PREFIX="{system_path}/prefix-template"
        USER_DATA="${{XDG_DATA_HOME:-$HOME/.local/share}}/{spec.app.name}"
        USER_PREFIX="$USER_DATA/prefix"
        EXE_PATH="{exe.path}"
        WORK_DIR="{work_dir}"
        ARGS="{exe.args}"
        
        # Token values for path replacement
        USER_TOKEN="__WINE_USER__"
        HOME_TOKEN="__USER_HOME__"
        ACTUAL_USER="$(whoami)"
        ACTUAL_HOME="$HOME"
        
        {init_block}
        
        {wine_block}
        
        # Set up environment
        export WINEPREFIX="$USER_PREFIX"
        
        # Optional: DXVK/VKD3D environment
        # export DXVK_LOG_LEVEL=none
        # export VKD3D_DEBUG=none
        
        # Change to working directory
        cd "$USER_PREFIX/$WORK_DIR"
        
        # Launch the application
        exec "$WINE" "$USER_PREFIX/$EXE_PATH" $ARGS "$@"
    ''')
    
    return script


def _generate_copy_init(system_path: str, user_data_path: str) -> str:
    """Generate initialization block that copies prefix on first run."""
    return dedent('''\
        # First-run initialization (copy mode)
        initialize_prefix() {
            echo "First run - initializing Wine prefix..."
            mkdir -p "$(dirname "$USER_PREFIX")"
            
            # Copy template to user directory
            cp -r "$SYSTEM_PREFIX" "$USER_PREFIX"
            
            # Replace path tokens with actual values
            for reg in "$USER_PREFIX"/*.reg; do
                if [[ -f "$reg" ]]; then
                    sed -i "s|$USER_TOKEN|$ACTUAL_USER|g" "$reg"
                    sed -i "s|$HOME_TOKEN|$ACTUAL_HOME|g" "$reg"
                fi
            done
            
            # Rename user directory
            if [[ -d "$USER_PREFIX/drive_c/users/$USER_TOKEN" ]]; then
                mv "$USER_PREFIX/drive_c/users/$USER_TOKEN" \\
                   "$USER_PREFIX/drive_c/users/$ACTUAL_USER"
            fi
            
            # Recreate dosdevices symlinks
            mkdir -p "$USER_PREFIX/dosdevices"
            ln -sf "../drive_c" "$USER_PREFIX/dosdevices/c:"
            ln -sf "/" "$USER_PREFIX/dosdevices/z:"
            
            echo "Prefix initialized at $USER_PREFIX"
        }
        
        if [[ ! -d "$USER_PREFIX" ]]; then
            initialize_prefix
        fi
    ''')


def _generate_overlay_init(system_path: str, user_data_path: str) -> str:
    """Generate initialization block using fuse-overlayfs."""
    return dedent('''\
        # First-run initialization (overlay mode)
        UPPER_DIR="$USER_DATA/upperdir"
        WORK_DIR_OVL="$USER_DATA/workdir"
        MERGED_DIR="$USER_PREFIX"
        
        initialize_overlay() {
            echo "First run - initializing overlay..."
            mkdir -p "$UPPER_DIR" "$WORK_DIR_OVL" "$MERGED_DIR"
            
            # Create initial registry files in upper layer with tokens replaced
            for reg in system.reg user.reg userdef.reg; do
                if [[ -f "$SYSTEM_PREFIX/$reg" ]]; then
                    sed "s|$USER_TOKEN|$ACTUAL_USER|g; s|$HOME_TOKEN|$ACTUAL_HOME|g" \\
                        "$SYSTEM_PREFIX/$reg" > "$UPPER_DIR/$reg"
                fi
            done
            
            # Create user directory structure in upper
            mkdir -p "$UPPER_DIR/drive_c/users/$ACTUAL_USER"

            # Create fresh dosdevices in upper (will overlay any from template)
            mkdir -p "$UPPER_DIR/dosdevices"
            rm -f "$UPPER_DIR/dosdevices/c:" "$UPPER_DIR/dosdevices/z:"
            ln -s "../drive_c" "$UPPER_DIR/dosdevices/c:"
            ln -s "/" "$UPPER_DIR/dosdevices/z:"
            
            echo "Overlay initialized"
        }
        
        mount_overlay() {
            if ! mountpoint -q "$MERGED_DIR" 2>/dev/null; then
                if ! fuse-overlayfs \
                    -o lowerdir="$SYSTEM_PREFIX" \
                    -o upperdir="$UPPER_DIR" \
                    -o workdir="$WORK_DIR_OVL" \
                    "$MERGED_DIR" 2>/dev/null; then
                    echo "Error: Failed to mount overlay filesystem" >&2
                    echo "Try running: rm -rf $USER_DATA" >&2
                    exit 1
                fi
            fi
        }

        if [[ ! -d "$UPPER_DIR" ]]; then
            initialize_overlay
        fi

        mount_overlay

        # Verify mount succeeded
        if [[ ! -d "$MERGED_DIR/drive_c" ]]; then
            echo "Error: Overlay mount failed - drive_c not found" >&2
            fusermount -u "$MERGED_DIR" 2>/dev/null || true
            exit 1
        fi
        
        # Ensure overlay is unmounted on exit
        cleanup() {
            fusermount -u "$MERGED_DIR" 2>/dev/null || true
        }
        trap cleanup EXIT
    ''')


def _generate_system_wine_block() -> str:
    """Generate Wine selection for system mode."""
    return dedent('''\
        # Wine binary selection (system mode)
        if command -v wine &>/dev/null; then
            WINE="wine"
        else
            echo "Error: Wine is not installed" >&2
            echo "Install Wine with your package manager:" >&2
            echo "  Arch: sudo pacman -S wine" >&2
            echo "  Debian/Ubuntu: sudo apt install wine" >&2
            echo "  Fedora: sudo dnf install wine" >&2
            exit 1
        fi
    ''')


def _generate_bundled_wine_block(system_path: str, bundled_path: str) -> str:
    """Generate Wine selection for bundled mode."""
    return dedent(f'''\
        # Wine binary selection (bundled mode)
        BUNDLED_WINE="{system_path}/{bundled_path}/bin/wine"
        
        if [[ -x "$BUNDLED_WINE" ]]; then
            WINE="$BUNDLED_WINE"
            # Add bundled Wine libs to path
            export LD_LIBRARY_PATH="{system_path}/{bundled_path}/lib:${{LD_LIBRARY_PATH:-}}"
        else
            echo "Error: Bundled Wine not found at $BUNDLED_WINE" >&2
            exit 1
        fi
    ''')


def generate_desktop_file(spec: PackageSpec, exe: Executable, exe_index: int = 0) -> str:
    """
    Generate .desktop file for an executable.

    Args:
        spec: Package specification
        exe: Executable to generate desktop file for
        exe_index: Index of this executable in the spec (0 for first)
    """
    # Determine command name (must match builder.py logic)
    if exe.command:
        exec_name = exe.command
    elif exe_index == 0:
        exec_name = spec.app.name
    else:
        exec_name = f"{spec.app.name}-{exe.id}"

    # Icon name matches the executable command name for consistency
    if exe.icon:
        icon = exec_name
    else:
        icon = "wine"

    categories = ";".join(exe.categories) + ";"

    # Use WM_CLASS matching the exe name (without .exe extension)
    wm_class = Path(exe.path).stem

    desktop = dedent(f'''\
        [Desktop Entry]
        Type=Application
        Name={exe.name}
        Comment={spec.app.description}
        Exec={exec_name}
        Icon={icon}
        Terminal=false
        Categories={categories}
        StartupWMClass={wm_class}
        Keywords=wine;windows;
    ''')

    return desktop


def generate_all_launchers(spec: PackageSpec) -> dict[str, str]:
    """
    Generate all launcher scripts for a package.

    Returns:
        Dict mapping filename to content
    """
    results = {}

    for i, exe in enumerate(spec.executables):
        script_name = exe.id
        results[f"bin/{script_name}"] = generate_launcher_script(spec, exe)

        if exe.create_desktop_entry:
            # Desktop file name matches command name
            if exe.command:
                desktop_name = f"{exe.command}.desktop"
            elif i == 0:
                desktop_name = f"{spec.app.name}.desktop"
            else:
                desktop_name = f"{spec.app.name}-{exe.id}.desktop"

            results[f"share/applications/{desktop_name}"] = generate_desktop_file(spec, exe, i)

    return results
