"""
Launcher script and desktop file generation.

Generates the shell scripts that handle first-run initialization
and Wine execution, plus .desktop files for menu integration.
"""

from __future__ import annotations

from pathlib import Path
from textwrap import dedent

from uncork.spec import PackageSpec, Executable, WineMode


def generate_launcher_script(spec: PackageSpec, exe: Executable) -> str:
    """
    Generate launcher shell script for an executable.

    The script handles:
    - First-run prefix initialization (copy or overlay)
    - Path token replacement
    - Wine binary selection (system vs bundled)
    - Environment setup
    - Cleanup via --cleanup or --uninstall flags
    """

    system_path = spec.get_system_path()
    user_data_path = spec.get_user_data_path()

    if spec.install.use_overlay:
        init_block = _generate_overlay_init(system_path, user_data_path)
    else:
        init_block = _generate_copy_init(system_path, user_data_path)

    if spec.wine.mode == WineMode.BUNDLED:
        wine_block = _generate_bundled_wine_block(system_path, spec.wine.bundled_path or "")
    else:
        wine_block = _generate_system_wine_block()

    # Working directory - resolve relative to prefix
    work_dir = exe.working_dir or str(Path(exe.path).parent)

    script = f'''#!/bin/bash
# Generated by uncork
# Launcher for {exe.name}

set -e

APP_NAME="{spec.app.name}"
SYSTEM_PREFIX="{system_path}/prefix-template"
USER_DATA="${{XDG_DATA_HOME:-$HOME/.local/share}}/{spec.app.name}"
USER_PREFIX="$USER_DATA/prefix"
EXE_PATH="{exe.path}"
WORK_DIR="{work_dir}"
ARGS="{exe.args}"

# Token values for path replacement
USER_TOKEN="__WINE_USER__"
HOME_TOKEN="__USER_HOME__"
ACTUAL_USER="$(whoami)"
ACTUAL_HOME="$HOME"

{init_block}

{wine_block}

# Set up environment
export WINEPREFIX="$USER_PREFIX"

# Optional: DXVK/VKD3D environment
# export DXVK_LOG_LEVEL=none
# export VKD3D_DEBUG=none

# Change to working directory
cd "$USER_PREFIX/$WORK_DIR"

# Launch the application
exec "$WINE" "$USER_PREFIX/$EXE_PATH" $ARGS "$@"
'''

    return script


def generate_cleanup_script(spec: PackageSpec) -> str:
    """
    Generate a universal cleanup script for unmounting overlays and removing user data.
    This can be called by package removal hooks or manually by users.
    """
    app_name = spec.app.name
    use_overlay = spec.install.use_overlay

    if not use_overlay:
        # No cleanup needed for copy mode
        return dedent('''\
            #!/bin/bash
            # No cleanup needed (not using overlay mode)
            exit 0
        ''')

    return dedent(f'''\
        #!/bin/bash
        # Universal cleanup script for {app_name}
        # Unmounts overlays and optionally removes user data

        set -e

        APP_NAME="{app_name}"
        REMOVE_DATA=false

        # Parse arguments
        while [[ $# -gt 0 ]]; do
            case $1 in
                --remove-data)
                    REMOVE_DATA=true
                    shift
                    ;;
                *)
                    shift
                    ;;
            esac
        done

        # Function to cleanup for a single user
        cleanup_user() {{
            local user_home="$1"
            local username=$(basename "$user_home")
            local user_data="${{user_home}}/.local/share/${{APP_NAME}}"
            local merged_dir="${{user_data}}/prefix"

            # Unmount if mounted
            if mountpoint -q "$merged_dir" 2>/dev/null; then
                echo "Unmounting overlay for user $username..."
                su - "$username" -c "fusermount -u '$merged_dir'" 2>/dev/null || \\
                fusermount -u "$merged_dir" 2>/dev/null || true
            fi

            # Remove user data if requested
            if [[ "$REMOVE_DATA" == "true" ]] && [[ -d "$user_data" ]]; then
                echo "Removing user data for $username..."
                rm -rf "$user_data" 2>/dev/null || true
            fi
        }}

        # Cleanup for all users
        for user_home in /home/*; do
            [[ -d "$user_home" ]] || continue
            cleanup_user "$user_home"
        done

        # Cleanup for current user if running as root
        if [[ $EUID -eq 0 ]] && [[ -n "$SUDO_USER" ]]; then
            if [[ -d "/home/$SUDO_USER" ]]; then
                cleanup_user "/home/$SUDO_USER"
            fi
        fi

        echo "Cleanup complete"
        exit 0
    ''')


def _generate_copy_init(system_path: str, user_data_path: str) -> str:
    """Generate initialization block that copies prefix on first run."""
    return dedent('''\
        # First-run initialization (copy mode)
        initialize_prefix() {
            echo "First run - initializing Wine prefix..."
            mkdir -p "$(dirname "$USER_PREFIX")"
            
            # Copy template to user directory
            cp -r "$SYSTEM_PREFIX" "$USER_PREFIX"
            
            # Replace path tokens with actual values
            for reg in "$USER_PREFIX"/*.reg; do
                if [[ -f "$reg" ]]; then
                    sed -i "s|$USER_TOKEN|$ACTUAL_USER|g" "$reg"
                    sed -i "s|$HOME_TOKEN|$ACTUAL_HOME|g" "$reg"
                fi
            done
            
            # Rename user directory
            if [[ -d "$USER_PREFIX/drive_c/users/$USER_TOKEN" ]]; then
                mv "$USER_PREFIX/drive_c/users/$USER_TOKEN" \\
                   "$USER_PREFIX/drive_c/users/$ACTUAL_USER"
            fi
            
            # Recreate dosdevices symlinks
            mkdir -p "$USER_PREFIX/dosdevices"
            ln -sf "../drive_c" "$USER_PREFIX/dosdevices/c:"
            ln -sf "/" "$USER_PREFIX/dosdevices/z:"
            
            echo "Prefix initialized at $USER_PREFIX"
        }
        
        if [[ ! -d "$USER_PREFIX" ]]; then
            initialize_prefix
        fi
    ''')


def _generate_overlay_init(system_path: str, user_data_path: str) -> str:
    """Generate initialization block using fuse-overlayfs."""
    return dedent('''\
        # First-run initialization (overlay mode)
        UPPER_DIR="$USER_DATA/upperdir"
        WORK_DIR_OVL="$USER_DATA/workdir"
        MERGED_DIR="$USER_PREFIX"

        # Cleanup function - unmount overlay
        cleanup_overlay() {
            if mountpoint -q "$MERGED_DIR" 2>/dev/null; then
                fusermount -u "$MERGED_DIR" 2>/dev/null || true
            fi
        }

        # Set up cleanup trap immediately
        trap cleanup_overlay EXIT INT TERM

        # Clean up any stale mounts before starting
        cleanup_overlay

        initialize_overlay() {
            echo "First run - initializing overlay..."
            mkdir -p "$UPPER_DIR" "$WORK_DIR_OVL" "$MERGED_DIR"

            # Create initial registry files in upper layer with tokens replaced
            for reg in system.reg user.reg userdef.reg; do
                if [[ -f "$SYSTEM_PREFIX/$reg" ]]; then
                    sed "s|$USER_TOKEN|$ACTUAL_USER|g; s|$HOME_TOKEN|$ACTUAL_HOME|g" \\
                        "$SYSTEM_PREFIX/$reg" > "$UPPER_DIR/$reg"
                fi
            done

            # Create user directory structure in upper
            mkdir -p "$UPPER_DIR/drive_c/users/$ACTUAL_USER"

            # Create fresh dosdevices in upper (will overlay any from template)
            mkdir -p "$UPPER_DIR/dosdevices"
            rm -f "$UPPER_DIR/dosdevices/c:" "$UPPER_DIR/dosdevices/z:"
            ln -s "../drive_c" "$UPPER_DIR/dosdevices/c:"
            ln -s "/" "$UPPER_DIR/dosdevices/z:"

            echo "Overlay initialized"
        }

        mount_overlay() {
            if ! mountpoint -q "$MERGED_DIR" 2>/dev/null; then
                if ! fuse-overlayfs \
                    -o lowerdir="$SYSTEM_PREFIX" \
                    -o upperdir="$UPPER_DIR" \
                    -o workdir="$WORK_DIR_OVL" \
                    "$MERGED_DIR" 2>/dev/null; then
                    echo "Error: Failed to mount overlay filesystem" >&2
                    echo "Try running: $0 --cleanup" >&2
                    exit 1
                fi
            fi
        }

        # Handle --cleanup flag
        if [[ "${1:-}" == "--cleanup" ]]; then
            echo "Cleaning up overlay mount..."
            cleanup_overlay
            echo "Cleanup complete. You can now remove user data with: rm -rf $USER_DATA"
            exit 0
        fi

        if [[ ! -d "$UPPER_DIR" ]]; then
            initialize_overlay
        fi

        mount_overlay

        # Verify mount succeeded
        if [[ ! -d "$MERGED_DIR/drive_c" ]]; then
            echo "Error: Overlay mount failed - drive_c not found" >&2
            cleanup_overlay
            exit 1
        fi
    ''')


def _generate_system_wine_block() -> str:
    """Generate Wine selection for system mode."""
    return dedent('''\
        # Wine binary selection (system mode)
        if command -v wine &>/dev/null; then
            WINE="wine"
        else
            echo "Error: Wine is not installed" >&2
            echo "Install Wine with your package manager:" >&2
            echo "  Arch: sudo pacman -S wine" >&2
            echo "  Debian/Ubuntu: sudo apt install wine" >&2
            echo "  Fedora: sudo dnf install wine" >&2
            exit 1
        fi
    ''')


def _generate_bundled_wine_block(system_path: str, bundled_path: str) -> str:
    """Generate Wine selection for bundled mode."""
    return dedent(f'''\
        # Wine binary selection (bundled mode)
        BUNDLED_WINE="{system_path}/{bundled_path}/bin/wine"
        
        if [[ -x "$BUNDLED_WINE" ]]; then
            WINE="$BUNDLED_WINE"
            # Add bundled Wine libs to path
            export LD_LIBRARY_PATH="{system_path}/{bundled_path}/lib:${{LD_LIBRARY_PATH:-}}"
        else
            echo "Error: Bundled Wine not found at $BUNDLED_WINE" >&2
            exit 1
        fi
    ''')


def generate_desktop_file(spec: PackageSpec, exe: Executable, exe_index: int = 0) -> str:
    """
    Generate .desktop file for an executable.

    Args:
        spec: Package specification
        exe: Executable to generate desktop file for
        exe_index: Index of this executable in the spec (0 for first)
    """
    # Determine command name (must match builder.py logic)
    if exe.command:
        exec_name = exe.command
    elif exe_index == 0:
        exec_name = spec.app.name
    else:
        exec_name = f"{spec.app.name}-{exe.id}"

    # Icon name matches the executable command name for consistency
    if exe.icon:
        icon = exec_name
    else:
        icon = "wine"

    # Use per-executable description if provided, otherwise fall back to app description
    comment = exe.description if exe.description else spec.app.description

    categories = ";".join(exe.categories) + ";"

    # Use WM_CLASS matching the exe name (Wine reports with .exe extension)
    wm_class = Path(exe.path).name

    # Use direct path to launcher script (not symlink) for better compatibility
    system_path = spec.get_system_path()
    exec_path = f"{system_path}/bin/{exe.id}"

    desktop = dedent(f'''\
        [Desktop Entry]
        Type=Application
        Name={exe.name}
        Comment={comment}
        Exec={exec_path}
        Icon={icon}
        Terminal=false
        Categories={categories}
        StartupWMClass={wm_class}
        Keywords=wine;windows;
    ''')

    return desktop


def generate_all_launchers(spec: PackageSpec) -> dict[str, str]:
    """
    Generate all launcher scripts for a package.

    Returns:
        Dict mapping filename to content
    """
    results = {}

    # Generate cleanup script (used by package removal hooks)
    results["bin/cleanup"] = generate_cleanup_script(spec)

    for i, exe in enumerate(spec.executables):
        script_name = exe.id
        results[f"bin/{script_name}"] = generate_launcher_script(spec, exe)

        if exe.create_desktop_entry:
            # Desktop file name matches command name
            if exe.command:
                desktop_name = f"{exe.command}.desktop"
            elif i == 0:
                desktop_name = f"{spec.app.name}.desktop"
            else:
                desktop_name = f"{spec.app.name}-{exe.id}.desktop"

            results[f"share/applications/{desktop_name}"] = generate_desktop_file(spec, exe, i)

    return results
